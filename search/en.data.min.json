[{"id":0,"href":"/documentation/post-renderers/built-in/","title":"Built-in","parent":"Post Renderers","content":"The following Post Renderers are built in and ship with the library.\n   Labels      "},{"id":1,"href":"/documentation/configuration/","title":"Configuration","parent":"Documentation","content":"The configuration is the core component which defines how your deployment structure will be organized\nFile     By default the configuration is located in a helmize.yaml file within your charts root folder. You will get errors if the configuration file is missing, has wrong formatting or types.\n"},{"id":2,"href":"/documentation/configuration/general/","title":"General","parent":"Configuration","content":"Configuration     The following general configuration options are available in the helmize.yaml\nconditions     Required\nType slice\nRead more about conditionsdropins     Required\nType slice\nRead more about dropinsinventory_directory     Optional\nType string\nDefine a directory where the entire structure for helmize is located below. This path will be appended for all the condition\u0026rsquo;s paths.\ntemplates_directory     Optional\nType string\nDefine a directory where all templates for the dropins templates are located below. This path will be appended for all the templates in all dropinsforce     Optional\nType string Default false\nIf any file contains an error the template will fail. With force the template won\u0026rsquo;t fail even if there are errors. Files with errors will be skipped.\nfile_extensions     Optional\nType string/slice Default [ \u0026quot;yaml\u0026quot;, \u0026quot;yml\u0026quot;, \u0026quot;tpl\u0026quot; ]\nDefine which file extensions should be considered while looking through the directories. Just declare the extension without wildcard, this configuration does not accept regex pattern.\nfile_excludes     Optional\nType string/slice\nDefine which file names should be considered while looking through the directories. You can use regex patterns.\nmerge_strategy     Optional\nType string/slice Default path Valid Options file, path\nDefine how files are merged together.\nfile     Merge file content based on file name. If you have multiple files with the exact same name in one condition folder or over multiple folders, they are considered to be one final file and merged together.\nLet\u0026rsquo;s assume you have the following folder structure:\nstructure | +---stage/ | +---dev/ | release.yaml | subdir/release.yaml | ... | +---location/ | +---east/ | release.yaml | subdir/release.yaml | ... + All the files named release.yaml will be merged together and as output you will get a single release.yaml file.\npath     Merge file content based on file subpath. If you have multiple files with teh exact same name but different subpaths they will not be merged together.\nLet\u0026rsquo;s assume you have the following folder structure:\nstructure | +---stage/ | +---dev/ | release.yaml | subdir/release.yaml | ... | +---location/ | +---east/ | release.yaml | subdir/release.yaml | ... + The release.yaml files are merged together and the subdir/release.yaml are merged together.\n"},{"id":3,"href":"/getting-started/","title":"Getting Started","parent":"","content":"    Requirements      Quickstart      Limitations     "},{"id":4,"href":"/documentation/post-renderers/built-in/labels/","title":"Labels","parent":"Built-in","content":"eow\n"},{"id":5,"href":"/getting-started/requirements/","title":"Requirements","parent":"Getting Started","content":"This documentation won\u0026rsquo;t explain the core concepts of Helmand Sprig templating, it is expected that you know these technologies.\nThe only requirement for helmize is helm. The library was tested with the following helm version:\n v3.7.2  "},{"id":6,"href":"/documentation/configuration/conditions/","title":"Conditions","parent":"Configuration","content":"Conditions translate into paths where files are looked up based on given values which are relevant for deployment. Conditions are declared as list, based on the order the files are looked up and merged.\nConfiguration     Each condition can have the followin configurations.\nname     Required\nType string\nUsed across helmize to reference to condition.\nkey     Optional\nType string\nPath to the value in the user delivered values which is used as key to lookup.\nrequired     Optional\nType boolean\nThe declared key must have a value. If no value is given the templating fails.\ndefault     Optional\nType string\nIf the declared key does not contain a value, this default value will be used.\npath     Optional\nType string\nThe path defines under which directory path the given values for the condition are looked up. If no path is given, the condition\u0026rsquo;s nameis used as path. Note that the path is complementary to the inventory_directoryfilter     Optional\nType string/slice\nFilter keylist for values that are not allowed and exclude them as valid path. The filter is executed against all inputs for this condition. If a filter matches a value, the value is removed. You can use regex patterns. The allow_rootis not affected by any filter and will always be added.\nreverseFilter     Optional\nType boolean\nReverses the filterconfiguration so that only values given with the filter are accepted.\nallow_root     Optional\nType boolean\nIn addition to checking all keys, it becomes also valid to have files directly in the root of the condition\u0026rsquo;s path.\n"},{"id":7,"href":"/documentation/","title":"Documentation","parent":"","content":"    Configuration      General      Conditions      Dropins      Reference        Structure      Templating        Post Renderers      Built-in      Labels        Extension        "},{"id":8,"href":"/documentation/post-renderers/extend/","title":"Extension","parent":"Post Renderers","content":"    "},{"id":9,"href":"/getting-started/quickstart/","title":"Quickstart","parent":"Getting Started","content":"First we create a new helm chart which is going to contain the entire deployment structure for helmize. We can simply do that with the following comment (In this case I will call the new chart reference, chose the name you would like):\nhelm create reference \u0026amp;\u0026amp; cd reference/ We can clear the templates/* content and the Çœalues.yaml, since we are going to recreate them.\nrm -rf templates/* \u0026amp;\u0026amp; rm -f values.yaml Now we add helmize as new chart dependency(Check out the release page or artifacthub to get the latest helmize version):\n# Chart.yaml ... dependencies: - name: helmize # Make sure to use a fixed version version: \u0026#34;\u0026gt;=0.0.0-0\u0026#34; repository: \u0026#34;https://buttahtoast.github.io/helm-charts/\u0026#34; ... Update dependencies to download the specified version for helmize:\nhelm dependency update Now we need to add a template which includes the entrypoint for helmize:\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./templates/deploy.yaml {{- include \u0026#34;inventory.entrypoint.func.deploy\u0026#34; $ | nindent 0 }} EOF Now we create a very simplistic configuration in the chart root:\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; templates_directory: \u0026#34;tpls/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; allow_root: true EOF With this initial configuration we have added a base directory which will lookup all files within.\nStructure     Now we start creating our structure for the chart. We want to deploy podinfo(just the deployment) in the referenced base:\nmkdir -p structure/base/podinfo Under the structure we create some files so we can see the influence of helmize\nBase Files ...  Create Deployment file\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/base/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: minReadySeconds: 3 revisionHistoryLimit: 5 progressDeadlineSeconds: 60 strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate selector: matchLabels: app: frontend template: metadata: annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/port: \u0026#34;9797\u0026#34; labels: app: frontend spec: containers: - name: frontend image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 9898 protocol: TCP - name: http-metrics containerPort: 9797 protocol: TCP - name: grpc containerPort: 9999 protocol: TCP command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#34;#34577c\u0026#34; livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi EOF Create Service file\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/base/podinfo/service.yaml apiVersion: v1 kind: Service metadata: name: frontend spec: type: ClusterIP selector: app: frontend ports: - name: http port: 80 protocol: TCP targetPort: http EOF    After you have added those files and execute a template command:\nhelm template . The result should not be surprising, for now the two new added files are just rendererd with additional comments.\nTemplate Result ...  --- # Source: reference/templates/deploy.yaml # File: podinfo/service.yaml # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # Source: reference/templates/deploy.yaml # File: podinfo/deploy.yaml # Checksum 71f6b6d50be2ddace75a2259b577150467e85a80c2c29a10dd402446edb028b8 apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: minReadySeconds: 3 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi    Condition     Read more on conditionsFor the quickstart we are going to add two conditions on top of the base condition called environment and location\nEnvironment     Now we want to add a condition, that podinfo is different names on different environments. The environment can be controlled via the values of the chart.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; templates_directory: \u0026#34;tpls/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; allow_root: true - name: \u0026#34;environment\u0026#34; key: \u0026#34;Values.env\u0026#34; path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; filter: [ \u0026#34;test\u0026#34;, \u0026#34;prod\u0026#34; ] reverseFilter: true EOF Now we add two new structures for the environment testand prod\nTest Environment ...  Create Directory based on condition configuration\nmkdir -p structure/env/test/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. In thase case we adjust the name and the minReadySeconds properties.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/test/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend-test spec: minReadySeconds: 10 EOF Create a HPA resource which should only be deployed on test\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/test/podinfo/hpa.yaml apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend-test minReplicas: 1 maxReplicas: 4 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 99 EOF Since we defined test as default for the environment we can template via\nhelm template . or with explicit value\nhelm template . --set \u0026#34;env=test\u0026#34; Both will result in the same output. Based on the output you can see that the hpa.yaml file is now rendered as well, but only if the environment is test. The Deployment files were also merged, since they both resolve into the subpath podinfo/deploy.yamlunderneath their condition folders.\nTest Environment ...  --- # Source: reference/templates/deploy.yaml # File: podinfo/service.yaml # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # File: podinfo/deploy.yaml # Checksum 30852c17c788e196ef62884c2e5bb092472a3b6b02d035bf39cdcbf6b54fc5e3 apiVersion: apps/v1 kind: Deployment metadata: name: frontend-test spec: minReadySeconds: 10 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi --- # Source: reference/templates/deploy.yaml # File: podinfo/hpa.yaml # Checksum 4669de4bb6631c64c7459e44b38c32a1236a0b7fb419b642d4a52b76ff51747c apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: maxReplicas: 4 metrics: - resource: name: cpu target: averageUtilization: 99 type: Utilization type: Resource minReplicas: 1 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend      Prod Environment ...  Create Directory based on condition configuration\nmkdir -p structure/env/prod/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. In thase case we adjust the name and the minReadySeconds properties.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/prod/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend-prod spec: minReadySeconds: 10 EOF For production we have to set the environment explicit\nhelm template . --set \u0026#34;env=prod\u0026#34; The Deployment files were also merged, since they both resolve into the subpath podinfo/deploy.yaml underneath their condition folders.\nProd Environment ...  --- # Source: reference/templates/deploy.yaml # File: podinfo/service.yaml # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # File: podinfo/deploy.yaml # Checksum f5f1922876fe509774c40afbd4576984bd3a952f248a3601a424966544a33892 apiVersion: apps/v1 kind: Deployment metadata: name: frontend-prod spec: minReadySeconds: 10 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi      As you can see the output changes based on the input of the chart.\nLocation     Let\u0026rsquo;s add a condition for the location. The location should also be controllable via Values of the chart.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; templates_directory: \u0026#34;tpls/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; allow_root: true - name: \u0026#34;environment\u0026#34; key: \u0026#34;Values.env\u0026#34; path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; filter: [ \u0026#34;test\u0026#34;, \u0026#34;prod\u0026#34; ] reverseFilter: true - name: \u0026#34;location\u0026#34; key: \u0026#34;Values.location\u0026#34; EOF Now we add two new structures for the location east and west\nEast Environment ...  Create Directory based on condition configuration\nmkdir -p structure/location/east/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. We just add a location label to identify the deployment.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/east/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: labels location: \u0026#34;east\u0026#34; EOF There is on purpose an error in the above YAML to show you what happens in such a case  Now we can start combining two condiditions. So for now let\u0026rsquo;s select prod as environment and east as location\nhelm template . --set \u0026#34;env=prod\u0026#34; --set \u0026#34;location=east\u0026#34; There\u0026rsquo;s an error!\nTemplate Error ...  Error: execution error at (reference/templates/deploy.yaml:1:4): Found errors in render manifest, please resolve those errors or use the force options: - error: \u0026#39;error converting YAML to JSON: yaml: line 5: mapping values are not allowed in this context\u0026#39; file: structure/location/east/podinfo/deploy.yaml trace: | apiVersion: apps/v1 kind: Deployment metadata: labels location: \u0026#34;east\u0026#34;    Let\u0026rsquo;s fix this error\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/east/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: labels: location: \u0026#34;east\u0026#34; EOF Now if we try the same template command again we get a result that looks much more like what we are looking for. As you can see we combined the two conditions prod and east. But we can do the exact same thing with every environment with every location, just by changing the values.\n  West Environment ...  Create Directory based on condition configuration\nmkdir -p structure/location/west/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. We just add a location label to identify the deployment.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/west/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: labels: location: \u0026#34;west\u0026#34; EOF Now we can start combining two condiditions. So for now let\u0026rsquo;s select test as environment and west as location\nhelm template . --set \u0026#34;env=test\u0026#34; --set \u0026#34;location=west\u0026#34; Now if we try the same template command again we get a result that looks much more like what we are looking for. As you can see we combined the two conditions test and west. But we can do the exact same thing with every environment with every location, just by changing the values.\nTest \u0026amp; West Environment ...  --- # Source: reference/templates/deploy.yaml # File: podinfo/service.yaml # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # File: podinfo/deploy.yaml # Checksum 3e8abeffd025ba5352bc97ab5cfb545902285dec8d27b6d1d46b8f44affd633b apiVersion: apps/v1 kind: Deployment metadata: labels: location: west name: frontend-test spec: minReadySeconds: 10 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi --- # Source: reference/templates/deploy.yaml # File: podinfo/hpa.yaml # Checksum 4669de4bb6631c64c7459e44b38c32a1236a0b7fb419b642d4a52b76ff51747c apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: maxReplicas: 4 metrics: - resource: name: cpu target: averageUtilization: 99 type: Utilization type: Resource minReplicas: 1 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend      "},{"id":10,"href":"/documentation/structure/","title":"Structure","parent":"Documentation","content":"    Templating      "},{"id":11,"href":"/documentation/structure/templating/","title":"Templating","parent":"Structure","content":"    "},{"id":12,"href":"/documentation/configuration/dropins/","title":"Dropins","parent":"Configuration","content":"Dropins are Values and templates which can be sustituted based on given path patterns. They allow greater customization through the use of sprig templates.\nConfiguration     Each dropin can have the followin configurations.\npatterns     Required\nType string/slice\nDefine regex patterns which match file paths you want to supply this dropin to.\ndata     Optional\nType map\nDefine data that will be available for the files that matched the pattern. You can not use sprig template here, the type must be map.\ntpls     Optional\nType string/slice\nTemplate locations to execute with thise dropin. Templates should be in dedicated files, otherwise they are very difficult to parse and hard to write for you as well. Therefor each value points to a template which is in a file. Each element can by a file or a path with template files in it.\nNOTE: The result of each template must be a valid dict, otherwise it\u0026rsquo;s considered an error.\nThe path is complementary to the templates_directorypath, if set.\n"},{"id":13,"href":"/getting-started/limitations/","title":"Limitations","parent":"Getting Started","content":""},{"id":14,"href":"/documentation/post-renderers/","title":"Post Renderers","parent":"Documentation","content":"    Built-in      Labels        Extension      "},{"id":15,"href":"/documentation/configuration/reference/","title":"Reference","parent":"Configuration","content":"Configuration Reference\ninventory_directory: \u0026#34;groups/\u0026#34; templates_directory: \u0026#34;tpls/\u0026#34; force: false file_extensions: [ \u0026#34;yaml\u0026#34; ] file_excludes: [ \u0026#34;kustomization\u0026#34; ] merge_strategy: \u0026#34;path\u0026#34; ## Conditions \u0026lt;slice\u0026gt; conditions: # Location Condition - name: \u0026#34;location\u0026#34; key: \u0026#34;Values.config.location\u0026#34; default: \u0026#34;default\u0026#34; # Location - name: \u0026#34;environment\u0026#34; key: \u0026#34;Values.config.environment\u0026#34; required: false default: \u0026#34;default\u0026#34; path: \u0026#34;/custom/path\u0026#34; filter: [ \u0026#34;dev\u0026#34; ] reverseFilter: false allow_root: true ..."},{"id":16,"href":"/","title":"","parent":"","content":"This project is in the early stages of development and still activiely maintained. You may encounter behavior that\u0026rsquo;s not intended when making use of the project.  Helmize is a simple deployment library wrapped in a library helm chart. It\u0026rsquo;s purpose is to simplify complex infrastructure deployments where you change deployed manifests based on given conditions. This project is thought for people that bootstrap complex infrastructure setup on kubernetes and want to simplify their file structure.\nConcept     Why     I have created this solution since I did not really find a fiting solution, which would allow me to create My first attempt was using Kustomize, which turned out to be a complex folder structure which is from my point of view not easily maintainable.\n https://github.com/fluxcd/kustomize-controller/issues/414  {{ partial \u0026ldquo;sidebar.html\u0026rdquo; . }}\n"},{"id":17,"href":"/categories/","title":"Categories","parent":"","content":""},{"id":18,"href":"/tags/","title":"Tags","parent":"","content":""}]