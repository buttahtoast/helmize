[{"id":0,"href":"/getting-started/concept/","title":"Concept","parent":"Getting Started","content":"Inner Workings Helmize is included as library chart. It just has all the function it needs to render the structure you give it and then returns the resulting contents. So it\u0026rsquo;s basically just a render engine.\nIn the below image we have the Releases (which are effecitively values which install your helm chart). In your helm chart you see different yamls organized in a structure which depends on input conditions eg. locations. Your chart includes a configuration filewhich defines these conditions and allows you to map it two values. Helmize will read the configuration and render inputs according to it.\nFor the Release Vanilla we see, that we have a configuration for the location which is east and a configuration for the env which is dev. On Install all files in the base/ folder are used, since these apply for all releases. For the location only the files in the location/east folder are considered. Same for the environment, only files in the environments/devfolder are considered. The release does not have a value for a customer but in the configuration we specified that the default value for customer is default. Therefor all files under customer/default are considered as well.\nFor the Release Customer A we see, that we have a value for the location which is west, a value for the env which is dev and prod and a value for customer which is A. On Install all files in the base/ folder are used, since these apply for all releases. For the location only the files in the location/west folder are considered. Same for the environment, only files in the environments/dev and environments/prod folder are considered. The customer is set to A therefor all files under customer/A are considered as well.\nFor both examples you might notice, that files with the same name are only present once in the resulting files. That\u0026rsquo;s because their content was merged. This way can just change eg. the version in the release.yaml without having to replicate the entire content and can adjust values on stage basis.\nThat\u0026rsquo;s it, See Quickstartfor an easy example how to setup helmize up.\n"},{"id":1,"href":"/guides/fluxcd/","title":"Fluxcd","parent":"Guides","content":"Helmize is a good match for Fluxcd. Especially when you start dealing with sub-dependencies. TBD\n"},{"id":2,"href":"/getting-started/","title":"Getting Started","parent":"","content":"    Concept      Quickstart      Helm     This documentation won\u0026rsquo;t explain the core concepts of Helmand Sprig templating, it is expected that you know these technologies.The only requirement for helmize is helm.\nRequirements     It\u0026rsquo;s required to use a Helm Version \u0026gt;= 3.5.0 (above or equal). Versions below are missing the addf function, which is used within helmize.\nTesting     Helmize is unit-tested with the following helm versions:\n v3.5.4 v3.6.3 v3.7.1 v3.8.2 latest  This way we can detect breaking changes and avoid them.\n"},{"id":3,"href":"/guides/helm/","title":"Helm","parent":"Guides","content":"The ecosystem of helm already provides different plugins and solutions which can be used to implement more advanced concepts.\nPost-Rendering     Helm offers the option to embed your own post renderers. They allow to usage of other executables. In contrast, our post renderers are a bit simpler, but just scoped to the possibilities Srig itself has to offer. Read more:\n https://helm.sh/docs/topics/advanced/#post-rendering  Secrets     Helm-Secretsis a great plugin which allows to encrypt helm secrets via sops.\nOther Solutions     There are different Solutions which help you to organize your secrets in a safe way:\n External Secrets SOPS Sealed Secrets  "},{"id":4,"href":"/configuration/helmize/","title":"Helmize","parent":"Configuration","content":"Options     The following options are available in the helmize.yaml. Read More conditions     Required\nType slice\nRead more about conditions inventory_directory     Optional\nType string Default structure/\nDefine a directory where the entire structure for helmize is located below. This path will be prepended for all the condition\u0026rsquo;s paths. The directory must be within the chart directry but not within the templates/ folder.\n file_extensions     Optional\nType string/slice Default [ \u0026quot;yaml\u0026quot;, \u0026quot;yml\u0026quot;, \u0026quot;tpl\u0026quot; ]\nDefine which file extensions should be considered while looking through the directories. Just declare the extension without wildcard, this configuration does not accept regex pattern.\n file_excludes     Optional\nType string/slice\nDefine which file names should be considered while looking through the directories. You can use regex patterns.\n file_config_key     Optional\nType string Default helmize\nKey within each\u0026rsquo;s file content which holds the file configuration. This value also allows nested paths (eg. metadata.config). After the config is source the entire key is removed from the content.\n identifier_template     Optional\nType string Default helmize.core.templates.identifier\nDefine a custom identifier template\nRead more about identifiers render_template     Optional\nType string Default helmize.render.templates.render\nDefine a custom render template\nRead more about Render renderers     Optional\nType slice\nRenderers are helm templates which are executed after all the files are merged. The Renderers are executed in given order.\nRead more about Renderers force     Optional\nType string Default false\nIf any file contains an error the template will fail. With force the template won\u0026rsquo;t fail even if there are errors. Files with errors will be skipped.\n"},{"id":5,"href":"/usage/templating/","title":"Templating","parent":"Usage","content":"Files     You can use templating in any file, with any extension. Helmize renders each file with sprigany validates, if it generates YAML output. You have access to the file contextwithin each file. Lets template! :)\nLibrary     Helmize comes with our helm library as dependency. The library provides a lot of functions which simplify the maniplution of dicts, slices, etc. You should definitly make use of it\u0026rsquo;s functionalities. See the full documentation of the library chart here:\n https://github.com/buttahtoast/helm-charts/tree/master/charts/library#templates  Recursive Merges     The mergering of files is not implement with the normal merge function from sprig. We have implemented our own merge function which allows the recusrive merging of list elements, which is per default not possible. Meaning you can merge the list objects from base data and new data and merge list elements of type dict based on an attribute. Which are crucial functionalities to reduce code and make life easier. See the documentation:\n https://artifacthub.io/packages/helm/buttahtoast/library#merge  This function might have some bugs, but we are doing our best to unit test it and make sure it works as expected.\nContexts     Contexts are data structures. In Sprig a template receives a context. Based on which context is given, you have acces to certain data.\nFile Context     With this example https://github.com/buttahtoast/helmize/tree/main/examples/datayou can see the file contexts. helm template . --set showContext=true  The context available in each file:\n See Condition Context See Global Context  File Context ...  # Condition Context of current file (1) \u0026lt;Condition Context\u0026gt; # Global Context (2) \u0026lt;Global Context\u0026gt;    Train Context     The train is a construct which mainly holds the general configuration and consists of wagons.\nTrain Context ...  # Conditions from Configuration conditions: - config: any: true key_types: - string - slice name: resources data: {} errors: [] keys: - / name: resources paths: - structure/resources/ root_path: resources value: {} - config: any: true key_types: - string - slice name: additional post_renderers: - customization.renderers.additional data: {} errors: [] keys: - / name: additional paths: - structure/additional/ root_path: additional value: {} # Origins of files paths: - _order: 0 config: fork: false no_match: append pattern: false render: true subpath: true data: {} file: structure/resources/daemonset.yaml ids: - daemonset-octopus-deployment.yaml partial_files: - |-# Content omitted # ... path: structure/resources/ post_renderers: [] value: {} - _order: 1 config: fork: false no_match: append pattern: false render: true subpath: true data: {} file: structure/resources/deploy.yaml ids: - deployment-octopus-deployment.yaml partial_files: - |-# Content omitted # ... path: structure/resources/ renderers: [] value: {} - _order: 2 config: fork: false no_match: append pattern: false render: true subpath: true # List of Wagons wagons: - \u0026lt;Wagon Context\u0026gt; - \u0026lt;Wagon Context\u0026gt; # Debug Messages (Transfered from Wagons) debug: [] # Error Messages (Transfered from Wagons) errors: - error: No Kind Defined file: - deployment renderer: customization.postrenderers.sidecar    Wagon Context     A wagon is the construct which abstracts a group of files into one file. The files are grouped into wagons based on their identifier. The Train is a list of wagon contexts.\nWagon Context ...  # Checksum is added after all the content is templated. The checksum is based on the value of the content field. checksum: 89b40c1c4e999c31f80f37a5cd49e582e81a15a6ed64b97f64921c3bfeeb29cc # Combined content of all files content: {} # Render State render: true # Indicates if this wagon was forked, only present when Wagon is a fork. fork: true # Holds all identifiers for this file id: - deployment - deployment.yaml # The subpath the files originated from subpath: . # All Executed Post-Renderers for this file in execution order renderers: - customization.postrenderers.additional - customization.postrenderers.sidecar - customization.postrenderers.env # Files which belong to this wagon (raw files) files: # Order the file was processed - _order: 1 # Applied File Configuration config: fork: false no_match: append pattern: false render: true subpath: true # Data given by condition data: {} # File path in structure file: structure/resources/deploy.yaml # Folder path in structure path: structure/resources/ # File Identifiers ids: - deployment-octopus-deployment.yaml # Renderers given by Conditions renderers: [] # Condition Value value: {} - _order: 5 config: fork: false no_match: append pattern: false render: true subpath: true data: {} file: structure/additional/existing_deploy.yaml ids: - deployment-octopus-deployment.yaml path: structure/additional/ renderers: [] value: {} # Debug Messages (Given by Identifier/Post Render Templates) debug: [] # Error Messages (Given by Identifier/Post Render Templates) errors: - error: No Kind Defined file: - deployment renderer: customization.postrenderers.sidecar    Global Context     The Global Context is the default helm context for a chart enriched with some extra fields for helmize.\nGlobal Context ...  # Helmize Configuration (1) Config: benchmark: false conditions: - any: true name: resources debug: false file_config_key: metadata.helmize file_extensions: - .yaml - .yml - .tpl force: true global: {} helmize: {} helmize_file: \u0026quot;\u0026quot; identifier_template: helmize.render.templates.identifier inventory_directory: structure/ library: global: {} renderers: - customization.postrenderers.sidecar - customization.postrenderers.env - customization.postrenderers.context render_template: helmize.entrypoint.templates.render show_config: false summary: false # Wagon Context of current file (4) Wagon: \u0026lt;Wagon Context\u0026gt; ## Usual Helm Context Values: given_values: \u0026quot;test\u0026quot; ... Release: IsInstall: true IsUpgrade: false Name: release-name Namespace: default Revision: 1 Service: Helm Template: BasePath: example-customization/templates Name: example-customization/templates/deploy.yaml etc..    Condition Context     The Condition is always available.\n All (previously) evaluated conditions can be accessed under $.conditions. The $.conditions.[*].value holds the resolved value from the $.conditions.[*].key property. When you template wagons, you can access the conditions Data field which selected this file via $.data (Reference to $.Conditions.[*].data field) When you template wagons, you can access the conditions Value field which selected this file via $.value (Reference to $.Conditions.[*].value field).  Condition Context ...  # Evaluated Conditions (1) conditions: # Condition Name - name: base # Applied Config for Condition config: any: true key_types: - string - slice name: base path: /base/ # Evaluated Data from templates data: {} # Errors errors: [] # Evaluated Keys keys: - / # Condition paths (for lookup) paths: - structure/base/ # Condition Root-Path (without inventory directoy) root_path: /base/ # Value evaluated from key value: {} - config: any: false default: test filter: - test - prod key: env key_types: - string - slice name: environment path: env/ reverse_filter: true data: {} errors: [] keys: - test name: environment paths: - structure/env/test/ root_path: env/ value: test # Condition Data (2) data: {} # Condition Value (3) value: {}    "},{"id":6,"href":"/configuration/helmize/conditions/","title":"Conditions","parent":"Helmize","content":"Conditions translate into paths where files are looked up based on given values which are relevant for deployment. Conditions are declared as list, based on the order the files are looked up and merged.\nOptions     Each condition can have the followin configurations.\n name     Required\nType string\nUsed across helmize to reference to condition.\n key     Optional\nType string\nPath to the value in the user delivered values which is used as key to lookup. The key is relative the Values ($.Values) and therefor must be within the Values.\n key_types     Optional\nType slice Default [ \u0026quot;string\u0026quot;, \u0026quot;slice\u0026quot; ]\nDefine the types the key must have. For example if you only want to allow a single value, the type should be string. Types you can use are documented here:\n http://masterminds.github.io/sprig/reflection.html   required     Optional\nType boolean\nThe declared key must have a value. If no value is given the templating fails.\n default     Optional\nType string\nIf the declared key does not contain a value, this default value will be used. The default value will be set the key if not set, so it\u0026rsquo;s available via the Values.\n path     Optional\nType string\nThe path defines under which directory path the given values for the condition are looked up. If no path is given, the condition\u0026rsquo;s nameis used as path. Note that the path is complementary to the inventory_directory filter     Optional\nType string/slice\nFilter keylist for values that are allowed values. The filter is executed against all inputs for this condition. If a value does not match the filter, an error is created for this condition. You can use regex patterns. The allow_rootis not affected by any filter and will always be added. The defaultvalue will also be added to the filter, if set.\n any     Optional\nType boolean Default false\nConsider any file in any subpath in the condition directory (Adding / as path).\n renderers     Optional\nType slice\nPost Renderers are helm templates which are executed after all the files are merged. Read More. On Conditions the post renderer is only run on files which originate from this condition. This also includes the case, if the file is merged with an existing file, the post renderer will be transfered on the merged file and is then executed. The Post Renderers are executed in given order. Post Renderers given by conditions are always executed before the general Post Renderers. Based on condition order the Post Renderers are appended on condition basis.\n file_cfg     Optional\nType \u0026lt;SharedFileConfiguration\u0026gt;\nYou can define file configurations for the entire condition. The file configurations are applied for all files in the directory of this condition. If\n Condition Data     It\u0026rsquo;s possible to give specific data with a condition. The data for the condition is then available for all files matching this condition and will be preserved for files which are rendered after this condition applied.\nConditions are validated before the file lookup happens. Therefor all resulting data from conditions is available for each file, no matter the order of the files or conditions.\n data     Optional\nType map\nDefine static data which will be availble for templating.\n tpls     Using templates might have a decrease in performance as consequence. Calling the sprig tpl functions tends to be a bit slow. However it might be a worthy trade-off for certain scenarios  Optional\nType list\nWith this parameter it\u0026rsquo;s possible to reference template files which are executed. Their output is treated as data and merged with the existing data key. Note that this is treated as regex, not absolut path. If a template does not result in valid YAML an error will be thrown and the condition is not applied. The templates are executed in order of definition. Data from previous templates as available the following templates, see the templating context ()\n"},{"id":7,"href":"/configuration/","title":"Configuration","parent":"","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-file-cfg The configuration is the core component which defines how your deployment structure will be organized. See which options you can configureValues     Using configuration via Values is great for testing or subcharts  All configurations can be set via values under the key helmize:\nhelmize: conditions: - __inject__ - name: \u0026quot;patches\u0026quot; file_cfg: pattern: false render: false required: false - name: \u0026quot;render_all\u0026quot; file_cfg: render: true data: additional: true The configuration via values is merged on top of the helmize configuration from file, should it exist. Here you can make use of Recursive MergesFile     Using a file for configuration has the advantage, that you can use templating within the file, which is not possible with the Values approach.  By default the configuration is located in a helmize.yaml file within your charts root folder. You will get errors if the configuration file is missing, has wrong formatting or types.\nTemplating     The entire configuration file is templated. So you can also use sprig within the configuration file. You must make sure that after the templating the content resolves to valid YAML, otherwise the exection will fail. The file must be within the chart directry but not within the templates/ folder.\nExample ...  chart/helmize.yaml\ninventory_directory: \u0026#34;structure/\u0026#34; conditions: {{- if $.Values.exclude_base }} - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; allow_root: true {{- end }} - name: \u0026#34;environment\u0026#34; key: {{ default \u0026#34;Values.env\u0026#34; $.Values.overwrite_env_key }} path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; When exclude_baseis set to false, the base condition won\u0026rsquo;t be used, since it\u0026rsquo;s not rendered in the configuration file:\nhelm template . --set exclude_base=false    "},{"id":8,"href":"/configuration/files/","title":"Files","parent":"Configuration","content":"Each file can be configured with different values to influence to behavior of helmize\nDeclaration     By default the configuration for each file can be made under a helmize key at the root of the yaml manifest. This would look like this:\nhelmize: id: - deploy - nginx subpath: false apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment ... You can change the configuration key via file_config_keyOptions     Per File Configuration     Each File can have the following properties.\n id     Optional\nType string/slice\nDefine custom id(s) for this file. Read more about identifiers Shared Configuration     The following properites can be set within each file but may also be configured conditions. Configurations on file basis are merged over condition file configurations.\n no_match     Optional\nType string Default \u0026quot;append\u0026quot; Valid Options append, skip\nDefine what happens if a file does not match any existing file with it\u0026rsquo;s identifiers:\n append - Append to file as new entry skip - Skip the file  This option is interesting for patches.\n max_match     Optional\nType float64 Default 0\nLimit the amount of matches this file can have. 0 are unlimited matches.\n render     Optional\nType boolean Default true\nDefine if a file should be rendered. The file will still show up in the summary but no be rendered when templating normally. When files are merged this option is overwritten as well. Eg. when the base file has render set to false and a file merges with it, with renderset to true, the result will be true\n subpath     Optional\nType boolean Default true\nMatch this file based on it\u0026rsquo;s subpath.\nExample ...  --- data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5 --- data: game.properties: | enemy: types: - imps - warriors player: maximumLives:10     pattern     When pattern is active, the file can oly be merged. If there\u0026rsquo;s no match, the file will be skipped, no matter which configuration is set for property no_match  Optional\nType boolean Default false\nThe identifiers are used as pattern (regex) to match against other ids.\nExample ...  Matches anything and adds a label to it\nstructure/patches/labels.yaml\nid: - \u0026quot;.*\u0026quot; cfg: subpath: false pattern: true metadata: labels: shared: \u0026quot;labels\u0026quot; To catch all files it should be in the last condition directory:\nhelmize.yaml\nconditions: ... - name: \u0026quot;patches\u0026quot; allow_root: true     fork     Optional\nType boolean Default false\nForks are new files based on their matches. If a files matches any file\u0026rsquo;s id it will create a new file. Only one fork can be created, so the first match creates the new file.\n"},{"id":9,"href":"/getting-started/quickstart/","title":"Quickstart","parent":"Getting Started","content":"If you encounter any problems during the quickstart make sure to use the flags. They help to understand what\u0026rsquo;s going on and what might be the problem.\nhttps://github.com/buttahtoast/helmize/tree/main/examples/reference First we create a new helm chart which is going to contain the entire deployment structure for helmize. We can simply do that with the following comment (In this case I will call the new chart reference, chose the name you would like):\nhelm create reference \u0026amp;\u0026amp; cd reference/ We can clear the templates/* content and the ǜalues.yaml, since we are going to recreate them.\nrm -rf templates/* \u0026amp;\u0026amp; rm -f values.yaml \u0026amp;\u0026amp; cd reference/ Now we add helmize as new chart dependency(Check out the release page or artifacthub to get the latest helmize version):\ncat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; ./Chart.yaml dependencies: - name: helmize # Make sure to use a fixed version version: \u0026#34;\u0026gt;=0.0.0-0\u0026#34; repository: \u0026#34;https://helmize.dev/\u0026#34; EOF Update dependencies to download the specified version for helmize:\nhelm dependency update Now we need to add a template which includes the entrypoint for helmize:\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./templates/deploy.yaml {{- include \u0026#34;helmize.deploy\u0026#34; $ | nindent 0 }} EOF Now we create a very simplistic configuration in the chart root. This configuration reads all files which are located in structure/base/\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; any: true EOF With this initial configuration we have added a base directory which will lookup all files within (it\u0026rsquo;s not reuired to have a base condition).\nStructure     Now we start creating our structure for the chart. We want to deploy podinfo(just the deployment) in the referenced base:\nmkdir -p structure/base/podinfo Under the structure we create some files so we can see the influence of helmize\nBase Files ...  Create Deployment file\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/base/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: minReadySeconds: 3 revisionHistoryLimit: 5 progressDeadlineSeconds: 60 strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate selector: matchLabels: app: frontend template: metadata: annotations: prometheus.io/scrape: \u0026#34;true\u0026#34; prometheus.io/port: \u0026#34;9797\u0026#34; labels: app: frontend spec: containers: - name: frontend image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 9898 protocol: TCP - name: http-metrics containerPort: 9797 protocol: TCP - name: grpc containerPort: 9999 protocol: TCP command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#34;#34577c\u0026#34; livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi EOF Create Service file\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/base/podinfo/service.yaml apiVersion: v1 kind: Service metadata: name: frontend spec: type: ClusterIP selector: app: frontend ports: - name: http port: 80 protocol: TCP targetPort: http EOF    After you have added those files and execute a template command:\nhelm template . The result should not be surprising, for now the two new added files are just rendererd with additional comments.\nTemplate Result ...  --- # Source: reference/templates/deploy.yaml # Identifers: [service-frontend.yaml] # Subpath: podinfo # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # Source: reference/templates/deploy.yaml # Identifers: [deployment-frontend.yaml] # Subpath: podinfo # Checksum 71f6b6d50be2ddace75a2259b577150467e85a80c2c29a10dd402446edb028b8 apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: minReadySeconds: 3 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi    Conditions     Read more on conditionsFor the quickstart we are going to add two conditions on top of the base condition called environment and location\nEnvironment     Now we want to add a condition, that podinfo is different names on different environments. The environment can be controlled via the values of the chart. The Value which is considered is defined under key which points to $.Values.env. If no value is given the default of test is applied. With the filter we define, that only test and prod are accepted as value. Files for this condition are located under structure/env/{value}:\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; any: true - name: \u0026#34;environment\u0026#34; key: \u0026#34;env\u0026#34; path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; filter: [ \u0026#34;test\u0026#34;, \u0026#34;prod\u0026#34; ] reverse_filter: true EOF Now we add two new structures for the environment testand prod\nTest Environment ...  Create Directory based on condition configuration\nmkdir -p structure/env/test/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. In this case we make some adjustments to the base deployment. We inject a different log level, change the UI color and overwrite the port number for the grpc port (Read More on how the merge works). You can access to condition\u0026rsquo;s Value via $.Value, that\u0026rsquo;s not possible in the base deployment file.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/test/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend labels: env: {{ $.value }} spec: progressDeadlineSeconds: 120 template: spec: containers: - name: frontend command: - __inject__ - --level=debug env: - name: PODINFO_UI_COLOR value: \u0026#39;#FAB418\u0026#39; ports: - __inject__ - containerPort: 20000 name: grpc EOF Create a HPA resource which should only be deployed on test\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/test/podinfo/hpa.yaml apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend-test minReplicas: 1 maxReplicas: 4 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 99 EOF Since we defined test as default for the environment we can template via\nhelm template . or with explicit value\nhelm template . --set \u0026#34;env=test\u0026#34; If you try with any other environment Helmize will fail:\n$ helm template . --set \u0026quot;env=dev\u0026quot; Error: execution error at (reference/templates/deploy.yaml:1:4): Found errors, please resolve those errors or use the force option (--set helmize.force=true): - condition: environment error: 'Value dev is not allowed (Allowed values: test, prod)' When you try with env=prod you will get the same output as with the base. Since we don\u0026rsquo;t have anything below structure/env/prod/. This condition slecets based on the value of $.Values.env.\nBoth will result in the same output. Based on the output you can see that the hpa.yaml file is now rendered as well, but only if the environment is test. The Deployment files were also merged, since they both resolve into the subpath podinfo/deploy.yamlunderneath their condition folders.\nTest Environment ...  --- # Source: reference/templates/deploy.yaml # Identifers: [service-frontend.yaml] # Subpath: podinfo # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # Source: reference/templates/deploy.yaml # Identifers: [deployment-frontend.yaml] # Subpath: podinfo # Checksum 576057612df9b3ceaae50d87000ad7b171deb16d870cd284e21a41b1bbb9248f apiVersion: apps/v1 kind: Deployment metadata: labels: env: test name: frontend spec: minReadySeconds: 3 progressDeadlineSeconds: 120 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 - --level=debug env: - name: PODINFO_UI_COLOR value: \u0026#39;#FAB418\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 20000 name: grpc protocol: TCP - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi --- # Source: reference/templates/deploy.yaml # Identifers: [horizontalpodautoscaler-frontend.yaml] # Subpath: podinfo # Checksum b3e231fd6bc48aa8e1c94208952372b01cec1f7afb7b756c386cd38d007bb976 apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: maxReplicas: 4 metrics: - resource: name: cpu target: averageUtilization: 99 type: Utilization type: Resource minReplicas: 1 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend-test      Prod Environment ...  Create Directory based on condition configuration\nmkdir -p structure/env/prod/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. For prod we just change the log level for the frontend. You can access to condition\u0026rsquo;s Value via $.Value, that\u0026rsquo;s not possible in the base deployment file.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/env/prod/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend labels: env: {{ $.value }} spec: template: spec: containers: - name: frontend command: - __inject__ - --level=info EOF For production we have to set the environment explicit\nhelm template . --set \u0026#34;env=prod\u0026#34; The Deployment files were also merged, since they both resolve into the subpath podinfo/deploy.yaml underneath their condition folders.\nProd Environment ...  --- # Source: reference/templates/deploy.yaml # Identifers: [service-frontend.yaml] # Subpath: podinfo # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # Source: reference/templates/deploy.yaml # Identifers: [deployment-frontend.yaml] # Subpath: podinfo # Checksum 927e03253e8b730aa0b982bba87da4eeab0349419e120476446823b95e0ba7a1 apiVersion: apps/v1 kind: Deployment metadata: labels: env: prod name: frontend spec: minReadySeconds: 3 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 - --level=info env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi      As you can see the output changes based on the input of the chart.\nLocation     Let\u0026rsquo;s add a condition for the location. The location should also be controllable via Values of the chart.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; any: true - name: \u0026#34;environment\u0026#34; key: \u0026#34;env\u0026#34; path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; filter: [ \u0026#34;test\u0026#34;, \u0026#34;prod\u0026#34; ] reverse_filter: true - name: \u0026#34;location\u0026#34; key: \u0026#34;location\u0026#34; default: \u0026#34;east\u0026#34; EOF Now we add two new structures for the location east and west\nEast Environment ...  Create Directory based on condition configuration\nmkdir -p structure/location/east/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. We just add a location label to identify the deployment.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/east/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: labels location: {{ $.value }} EOF There is on purpose an error in the above YAML to show you what happens in such a case  Now we can start combining two condiditions. So for now let\u0026rsquo;s select prod as environment and east as location\nhelm template . --set \u0026#34;env=prod\u0026#34; --set \u0026#34;location=east\u0026#34; There\u0026rsquo;s an error!\nTemplate Error ...  Error: execution error at (reference/templates/deploy.yaml:1:4): Found errors, please resolve those errors or use the force option (\u0026ndash;set helmize.force=true):\n error: 'error converting YAML to JSON: yaml: line 5: mapping values are not allowed in this context' file: structure/location/east/podinfo/deploy.yaml trace: | apiVersion: apps/v1 kind: Deployment metadata: labels location: east  Use \u0026ndash;debug flag to render out invalid YAML \n  Let\u0026rsquo;s fix this error\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/east/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend labels: location: {{ $.value }} EOF Now if we try the same template command again we get a result that looks much more like what we are looking for. As you can see we combined the two conditions prod and east. But we can do the exact same thing with every environment with every location, just by changing the values.\n  West Environment ...  Create Directory based on condition configuration\nmkdir -p structure/location/west/podinfo/ Create under the same path as in the base (podinfo/deploy.yaml) we want to merge over the file from the base. We just add a location label to identify the deployment.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/location/west/podinfo/deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: frontend labels: location: \u0026#34;west\u0026#34; EOF Now we can start combining two condiditions. So for now let\u0026rsquo;s select test as environment and west as location\nhelm template . --set \u0026#34;env=test\u0026#34; --set \u0026#34;location=west\u0026#34; Now if we try the same template command again we get a result that looks much more like what we are looking for. As you can see we combined the two conditions test and west. But we can do the exact same thing with every environment with every location, just by changing the values.\nTest \u0026amp; West Environment ...  --- # Source: reference/templates/deploy.yaml # File: podinfo/service.yaml # Checksum 08b06c48a587e3fe6179875f70331bb97562a6e584dcb32807ce9eac7572fc8d apiVersion: v1 kind: Service metadata: name: frontend spec: ports: - name: http port: 80 protocol: TCP targetPort: http selector: app: frontend type: ClusterIP --- # File: podinfo/deploy.yaml # Checksum 3e8abeffd025ba5352bc97ab5cfb545902285dec8d27b6d1d46b8f44affd633b apiVersion: apps/v1 kind: Deployment metadata: labels: location: west name: frontend-test spec: minReadySeconds: 10 progressDeadlineSeconds: 60 revisionHistoryLimit: 5 selector: matchLabels: app: frontend strategy: rollingUpdate: maxUnavailable: 0 type: RollingUpdate template: metadata: annotations: prometheus.io/port: \u0026#34;9797\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: app: frontend spec: containers: - command: - ./podinfo - --port=9898 - --port-metrics=9797 - --level=info - --backend-url=http://backend:9898/echo - --cache-server=cache:6379 env: - name: PODINFO_UI_COLOR value: \u0026#39;#34577c\u0026#39; image: ghcr.io/stefanprodan/podinfo:6.0.3 imagePullPolicy: IfNotPresent livenessProbe: exec: command: - podcli - check - http - localhost:9898/healthz initialDelaySeconds: 5 timeoutSeconds: 5 name: frontend ports: - containerPort: 9898 name: http protocol: TCP - containerPort: 9797 name: http-metrics protocol: TCP - containerPort: 9999 name: grpc protocol: TCP readinessProbe: exec: command: - podcli - check - http - localhost:9898/readyz initialDelaySeconds: 5 timeoutSeconds: 5 resources: limits: cpu: 1000m memory: 128Mi requests: cpu: 100m memory: 32Mi --- # Source: reference/templates/deploy.yaml # File: podinfo/hpa.yaml # Checksum 4669de4bb6631c64c7459e44b38c32a1236a0b7fb419b642d4a52b76ff51747c apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: frontend spec: maxReplicas: 4 metrics: - resource: name: cpu target: averageUtilization: 99 type: Utilization type: Resource minReplicas: 1 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: frontend      As seen with these two examples, conditions are a great mechanism to combine different indepdendent factors. You can extended the conditions at anytime without restructering the entire folder structure.\nConditional Data     Throughout the entire rendering process you can access the different data contexts and add logic to the given values. Now we add a new condition, which evaluates the required data, to atuomaticaly adjust the ingress based on previous cdonditions.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml inventory_directory: \u0026#34;structure/\u0026#34; conditions: - name: \u0026#34;base\u0026#34; path: \u0026#34;/base/\u0026#34; any: true - name: \u0026#34;environment\u0026#34; key: \u0026#34;env\u0026#34; path: \u0026#34;env/\u0026#34; default: \u0026#34;test\u0026#34; filter: [ \u0026#34;test\u0026#34;, \u0026#34;prod\u0026#34; ] reverse_filter: true - name: \u0026#34;location\u0026#34; key: \u0026#34;location\u0026#34; default: \u0026#34;east\u0026#34; - name: \u0026#34;expose\u0026#34; any: true data: ingress_class: \u0026#34;company-domain\u0026#34; tpls: - tpls/ingress.tpl EOF This condition implements a data templatewhich evaluates data. This template can use sprig. and you can add as many as you want, just make sure they return valid yaml. In addition we declare static data. Now let\u0026rsquo;s create the template:\nmkdir -p tpls/ This template evaluates the field ingress_name based on the previous values from conditions. This is a very simple example, you can increase the complexity by as much as you are comfortable with :).\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./helmize.yaml {{/* Default Variables */}} {{- $env := \u0026#34;\u0026#34; -}} {{- $location := \u0026#34;\u0026#34; -}} {{/* Iterate over previous Conditions */}} {{- range $c := $.conditions -}} {{/* Evaluate Environment */}} {{- if (eq $c.name \u0026#34;environment\u0026#34;) -}} {{- $env = default \u0026#34;\u0026#34; $c.value -}} {{/* Evaluate Location */}} {{- else if (eq $c.name \u0026#34;location\u0026#34;) -}} {{- $location = default \u0026#34;\u0026#34; $c.value -}} {{- end -}} {{- end -}} {{/* Return Data */}} ingress_name: frontend.{{ $env }}.{{ $location }}.company.com EOF Now lets create the file which will implement this data.\nmkdir -p structure/expose/ This template accesses the data. Since it\u0026rsquo;s coming from the condition, which sources the ingress, it can directly access the data via $.data. You could also do the same evaluation within this template, since you can access $.conditions in this context as well. This decision really comes down to how reusable the data must be and how many files implement it.\ncat \u0026lt;\u0026lt; EOF \u0026gt; ./structure/expose/ingress.tpl apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: frontend annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: {{- with $.data.ingress_class }} ingressClassName: {{ . }} {{- end }} tls: - hosts: - {{ $.data.ingress_name }} secretName: frontend-tls rules: - http: paths: - host: {{ $.data.ingress_name }} path: / pathType: Prefix backend: service: name: frontend port: number: 80 EOF Templating this, will result in a different ingress based on previous conditions, truly value driven. These were some very simple examples on how Helmize works.\nHelmize has a lot to offer, are you ready to explore it\u0026rsquo;s possabilities?\n"},{"id":10,"href":"/usage/","title":"Usage","parent":"","content":"Here\u0026rsquo;s a simplified overview of the workflow that helmize goes through in order to render files. Understanding the workflow might help with the different usage topics, since they are referenced below in which step they become relevant.\nTo give a bit more context:\n 1/2: To initialize Helmize tries to resolve to configurationthat is used. If the configuration is valid Helmize will fail with an indicating error. 3: The resulting conditions extract based on the given configuration Dataand paths which will be lookedfor potential files. 4: Based on the given paths, files are looked up. Only files which are not in the templates/ folder of the chart can be looked up. That\u0026rsquo;s why the structure is outside of the templates folder. 5: Once all files are collected (just the paths) the so called file trainis initialized. The file train has wagons, which are representative for resulting files. 6: Each file is now parsed. First it\u0026rsquo;s split into partial files, this is used for multi yamlsupport. then each partial file is evaluated. Based on the file\u0026rsquo;s configeach partial file is created/merged into a wagon within the file train. To identify how the wagons are identified, the identifier templateis used. Based on the identifiers of a partial file and other configurations it\u0026rsquo;s added to the file train. This loop is execute until all partial files from all paths are converted/applied into/to wagons. 7: The file train is initialized, now Renderersare executed, to enrich all the wagons after they are processed. 8: The file train is rendered as yaml. That\u0026rsquo;s defined in the Render Template. There are other output options via flags  And that\u0026rsquo;s all it does.\n"},{"id":11,"href":"/usage/yaml/","title":"YAML","parent":"Usage","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-yaml Multi YAML Helmize supports multi YAML files (Multiple YAMLs in one file separeted by - - -). The implementation is relativ primitive: If a file contains it\u0026rsquo;s split into multiple sub files, which then are treated as seperated files for further processing.\nLimitation The fromYaml function can not parse multiple yaml files, but is aware of the delimiter. If you have the following example:\n{{- define \u0026#34;sample.data\u0026#34; -}} --- First: YAML --- Second: YAML {{- end -}} {{- $t := (fromYaml (include \u0026#34;sample.data\u0026#34; $)) -}} {{- toYaml $t -}} You will get the following output:\n$ helm template . --- # Source: test/templates/test.yaml First: YAML Meaning the function only parses the first YAML found.\nWorkaround This is simplified version of how helmize parses multi YAML files. In the first step the entire file is templated (So it\u0026rsquo;s also possible to generate more files via templating within a file). The input is still of type string. No the entire content is split by --- resulting in sub files. In the iteration it\u0026rsquo;s checked if there is any content (when two --- come after each other the splitList function will create a entry with \u0026quot; \u0026quot;. Therefor we check if its empy without spaces). Then the content is loaded to yaml (and verified if the yaml is valid).\nNOTE: The split looks for \\n---. So make sure YAML indicators come after a linebreak.\n{{- define \u0026#34;sample.data\u0026#34; -}} --- First: {{ $.Release.Name }} --- Second: YAML --- --- third: YAML {{- end -}} {{- $t := (tpl (include \u0026#34;sample.data\u0026#34; $) $) -}} {{- $f := splitList \u0026#34;---\u0026#34; $t | compact -}} {{- range $i, $c := $f -}} {{- if ($c | nospace | trimAll \u0026#34;\\n\u0026#34;) }} {{ $i }}: {{- toYaml (fromYaml ($c)) | nindent 0 }} {{- end }} {{- end -}} The result for the above template is:\n$ helm template . --- # Source: test/templates/test.yaml 0: First: release-name 1: Second: YAML 3: third: YAML Understanding this might help working with multi YAML files.\nHints Here are some hints regarding Multi YAML files\nNested YAML Data You can still use multi line YAML\u0026rsquo;s, our implementation should not interefer with them:\nstructure/resources/multi-line.yaml\n--- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap data: entrypoint.sh: |-#!/bin/bash echo \u0026#34;Do this\u0026#34; game.properties: |--- enemy: types: - alien - monsters player: maximumLives:5 Wrong Templating There might be cases where to templating does not validate correctly and therefor you might have unexpected output. Take for example this template:\nstructure/resources/wrong-template.yaml\n{{- range $f, $d := (fromYaml (include \u0026#34;data\u0026#34; $)).data -}} --- apiVersion: v1 kind: ConfigMap metadata: name: configmap-{{ $f }} data: field: {{ $d }} {{- end -}} {{- define \u0026#34;data\u0026#34; -}} data: name_1: val_1 name_2: val_2 name_3: val_3 {{- end -}} But as output we only get:\n# Source: multi-yaml/templates/deploy.yaml # File: [configmap-configmap-name_3.yaml] # Checksum 7cc3553b2b3ec675cbdad142ce0293cc4f523d3d5aed8bd46d42451f82c3d7bc apiVersion: v1 data: field: val_3 kind: ConfigMap metadata: name: configmap-name_3 The other two configmaps are missing. With the summary we can see what happened:\nSummary ...  helm template . --set summary=true --set debug=true ... paths: ... - _order: 5 config: no_match: append subpath: true file: structure/resources/wrong-template.yaml ids: - configmap-configmap-name_3.yaml partial_files: - |---- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_1 data: field: val_1--- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_2 data: field: val_2--- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_3 data: field: val_3 path: structure/resources/    Under partial_files we should see 3 entries. Instead it\u0026rsquo;s a single entry. That\u0026rsquo;s because the split does not match \\n--- because the template does not print a new line after each iteration. Let\u0026rsquo;s fix that in the template (Note the missing - in the closing brackets):\nstructure/resources/wrong-template.yaml\n{{- range $f, $d := (fromYaml (include \u0026#34;data\u0026#34; $)).data }} --- apiVersion: v1 kind: ConfigMap metadata: name: configmap-{{ $f }} data: field: {{ $d }} {{- end }} Now if we look again at the summary, we see three entries and all three configmaps are printed:\nSummary ...  helm template . --set summary=true --set debug=true ... paths: ... - _order: 5 config: no_match: append subpath: true file: structure/resources/wrong-template.yaml ids: - configmap-configmap-name_3.yaml partial_files: - |2- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_1 data: field: val_1 - |2- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_2 data: field: val_2 - |2- apiVersion: v1 kind: ConfigMap metadata: name: configmap-name_3 data: field: val_3 path: structure/resources/    Examples You can find this example hereHelm Repository Iteration ...  Create an iteration creates multiple Helm Repositoriesbased on values:\nstructure/resources/repositories.yaml\n{{- if $.Values.public_repos -}} {{- range $repo_name, $repo_url := $.Values.public_repos }} --- apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: HelmRepository metadata: name: {{ $repo_name }} spec: url: {{ $repo_url }} interval: {{ default \u0026#34;5m0s\u0026#34; $.Values.repo.interval }} {{- end }} {{- end -}} Values which feed the tempalte:\nvalues.yaml\nrepo: interval: \u0026#34;1m\u0026#34; public_repos: metallb: https://metallb.github.io/metallb jetstack: https://charts.jetstack.io external_dns: https://kubernetes-sigs.github.io/external-dns/ For each entry under public_repos we expect a dedicated YAML:\nResult ...  --- # Source: multi-yaml/templates/deploy.yaml # File: [helmrepository-external_dns.yaml] # Checksum 7ae7ae809c40251fb91209b1afe4bd864657667ef828df5a9cd9455af576fc22 apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: HelmRepository metadata: name: external_dns spec: interval: 1m url: https://kubernetes-sigs.github.io/external-dns/ --- # Source: multi-yaml/templates/deploy.yaml # File: [helmrepository-jetstack.yaml] # Checksum c879ba5993cc035b2d9dfc9a7fa7987662da78ce85264ce29105136049de01ed apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: HelmRepository metadata: name: jetstack spec: interval: 1m url: https://charts.jetstack.io --- # Source: multi-yaml/templates/deploy.yaml # File: [helmrepository-metallb.yaml] # Checksum 6eb95220b4e806bf10faf4b880ee57f7874d72c9e85043d16e59f22a5af1027d apiVersion: source.toolkit.fluxcd.io/v1beta1 kind: HelmRepository metadata: name: metallb spec: interval: 1m url: https://metallb.github.io/metallb      "},{"id":12,"href":"/usage/identifiers/custom/","title":"Custom Template","parent":"Identifiers","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-customization You can implement your own identifier template, if ours is not practical for you. Let\u0026rsquo;s see how it\u0026rsquo;s done.\nConfiguration     General configuration for Identifiers.\nAssignment     After the Identifier template is executed, the content in $.wagon.id is considered as the result of the template and is used for each file. Should the value of this field be unset or empty, the filename of the current executed file is used. You should avoid using the filename because it may result in unwanted behavior if you have multi yaml files. The value for $.wagon.id is directly set on the context eg.\n{{- define \u0026quot;customization.identifier.template\u0026quot; -}} {{- $_ := set $.wagon \u0026quot;id\u0026quot; \u0026quot;sample\u0026quot; -}} {{- end -}} Return     The following return values (YAML Print) are considered:\n  errors - \u0026lt;slice\u0026gt; A list of errors which occured during identifier evaluation. The error will make helmize fail with your error message.\n  debug - \u0026lt;slice\u0026gt; Debug output which can be seen in summary (If something isn\u0026rsquo;t doing what you thought it does).\n  The Values are not required to be returned, only if you would like to invoke error/debug messages.\nValidation     The returned YAML is validated, if the YAML is not valid an error is thrown:\nTemplate customization.identifier.template returned invalid YAML (error converting YAML to JSON: yaml: line 1: did not find expected key): debug: [] errors: []debug: [] errors: [] In this case your printed YAML from the template is wrong, please fix.\nTemplate     Here\u0026rsquo;s a minimalstic Post Renderer template to get started.\n{{- define \u0026#34;customization.identifier.template\u0026#34; -}} {{- $return := dict \u0026#34;errors\u0026#34; list \u0026#34;debug\u0026#34; list -}} {{/* Identifier Logic */}} ... {{/* Return Metadata (Errors/Debug) */}} {{- printf \u0026#34;%s\u0026#34; (toYaml $return) -}} {{- end -}} Context     An Identifier template receives the following context (Values Change per File):\nContext ...  # Wagon (Current File) information wagon: config: fork: false no_match: append pattern: false render: true subpath: true debug: [] errors: [] file_id: file: structure/additional/new_deploy.yaml filename: new_deploy.yaml path: structure/additional id: [] post_renderers: - customization.postrenderers.additional render: true subpath: . content: apiVersion: apps/v1 kind: Deployment metadata: labels: app: web name: new-deployment spec: replicas: 1 selector: matchLabels: app: new-deployment strategy: type: RollingUpdate template: metadata: labels: app: new-deployment spec: affinity: podAntiAffinity: preferredDuringSchedulingIgnoredDuringExecution: - podAffinityTerm: labelSelector: matchExpressions: - key: app operator: In values: - web topologyKey: kubernetes.io/hostname weight: 100 containers: - env: - name: DEMO_GREETING value: Hello from the environment - name: DEMO_FAREWELL value: Such a sweet sorrow - name: EXISTING_VAR value: Some existing value image: nginx name: nginx ports: - containerPort: 80 ## Global Helm Context ctx: ...    Example     Let\u0026rsquo;s create a new Render template which only renders resources, if a specific annotation is set.\ntemplates/_identifier.tpl ...  The identifier calls the default identifier template first. Then it\u0026rsquo;s checked if there\u0026rsquo;s a field set in the content of a file called super_identifier. If that\u0026rsquo;s true, the value of said field is matched against a dns-1123 regex. If the regex matches, the value is set as only identifier for the file, overwriting all the other identifiers. A debug message is added indicating, that a super identifier was assigned. If the regex does not match, an error is thrown. If the field super_identifier is not set, nothing happens.\n{{- define \u0026#34;customization.identifier.template\u0026#34; -}} {{- $return := dict \u0026#34;errors\u0026#34; list \u0026#34;debug\u0026#34; list -}} {{/* Execute the default identifier Template (Redirect it\u0026#39;s output into nowhere) */}} {{- $_ := include (include \u0026#34;helmize.config.defaults.identifier_template.value\u0026#34; $) $ -}} {{/* Lookup field super identifier, an Overwrite existing ids, if present */}} {{- $content_path := \u0026#34;super_identifier\u0026#34; -}} {{- $super_identifier := (default \u0026#34;\u0026#34; (fromYaml (include \u0026#34;lib.utils.dicts.get\u0026#34; (dict \u0026#34;path\u0026#34; $content_path \u0026#34;data\u0026#34; $.wagon.content))).res) -}} {{/* Super Identifier */}} {{- if $super_identifier -}} {{/* DNS1123 Regex (Simplified) */}} {{- $regex := \u0026#34;^[A-Za-z0-9_.]{1,63}$\u0026#34; -}} {{/* Verify if name matches DNS1123 Regex */}} {{- if (regexMatch $regex $super_identifier) -}} {{/* Assign Identifier */}} {{- $_ := set $.wagon \u0026#34;id\u0026#34; $super_identifier -}} {{/* Debug */}} {{- $_ := set $return \u0026#34;debug\u0026#34; (append $return.debug (printf \u0026#34;%s is a super identifier\u0026#34; $super_identifier)) -}} {{/* Remove Field from Content */}} {{- include \u0026#34;lib.utils.dicts.unset\u0026#34; (dict \u0026#34;path\u0026#34; $content_path \u0026#34;data\u0026#34; $.wagon.content) -}} {{/* Throw Error */}} {{- else -}} {{- $_ := set $return \u0026#34;errors\u0026#34; (append $return.errors (printf \u0026#34;%s did not match regex %s\u0026#34; $super_identifier $regex)) -}} {{- end -}} {{- end -}} {{- printf \u0026#34;%s\u0026#34; (toYaml $return) -}} {{- end -}}    Once the identifier template is created we need to reference in the configuration:\nidentifier_template: \u0026#34;customization.identifier.template\u0026#34; conditions: - name: \u0026#34;resources\u0026#34; allow_root: true - name: \u0026#34;additional\u0026#34; allow_root: true "},{"id":13,"href":"/usage/render/custom/","title":"Custom Template","parent":"Render","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-customization You can implement your own render template. The render template constructs the output YAML when templating the entire structure.\nConfiguration     General configuration for a Render Template.\nTemplate     Here’s a minimalstic Renderer Template to get started.\n{{- define \u0026#34;render.template\u0026#34; -}} {{- range $wagon := $.train.wagons -}} {{/* Render Logic */}} {{/* Include Default Wagon Render Template (If you still want to use our template) */}} {{- include \u0026#34;helmize.entrypoint.templates.render.wagon\u0026#34; (dict \u0026#34;wagon\u0026#34; $wagon \u0026#34;ctx\u0026#34; $.ctx) -}} {{- end -}} {{- end -}} Context     An Identifier template receives the following context (Values Change per File):\nContext ...  Example     Example https://github.com/buttahtoast/helmize/tree/main/examples/customization\u0026lt;/a\n  In the helmize.yaml which template we want to use ():\ntemplates/_render.tpl ...  The identifier calls the default identifier template first. Then it\u0026rsquo;s checked if there\u0026rsquo;s a field set in the content of a file called super_identifier. If that\u0026rsquo;s true, the value of said field is matched against a dns-1123 regex. If the regex matches, the value is set as only identifier for the file, overwriting all the other identifiers. A debug message is added indicating, that a super identifier was assigned. If the regex does not match, an error is thrown. If the field super_identifier is not set, nothing happens.\n{{- define \u0026#34;customization.render.template\u0026#34; -}} {{- range $wagon := $.train.wagons -}} {{/* Validate Annotations */}} {{- if (get (default dict $wagon.content.metadata.labels) \u0026quot;render\u0026quot;) -}} {{- $_ := set $wagon \u0026quot;render\u0026quot; false -}} {{- end -}}\n{{/* Include Default Wagon Render Template */}} {{- include \u0026quot;helmize.entrypoint.templates.render.wagon\u0026quot; (dict \u0026quot;wagon\u0026quot; $wagon \u0026quot;ctx\u0026quot; $.ctx) -}}\n{{- end -}} {{- end -}} \n  Once the render template is created we need to reference in the configuration:\nrender_template: \u0026#34;customization.render.template\u0026#34; conditions: - name: \u0026#34;resources\u0026#34; any: true - name: \u0026#34;additional\u0026#34; any: true    "},{"id":14,"href":"/usage/data/","title":"Data","parent":"Usage","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/data Data is shared over a specific field across all files. Data can originate from Conditionsor you can manipulate the data to a certain extend.\nManipulate     With Data manipulation you can potentialy break the entire functionality. Make sure to only manipulate values under $.Data and be aware of what you are doing.  You can manipulate data from files into the shared file store, since the set and unset execute on the interface and do not return a result. Such operations can be done in files with don\u0026rsquo;t have any content at all and no matching id, since the given context which templates the file is target by those operations.\nInject     This way you add data, which will be available for all the following files:\nstructure/layer_2/_inject.yaml ...  {{- $_ := set $.data \u0026quot;inject\u0026quot; (dict \u0026quot;msg\u0026quot; \u0026quot;inject data into shared data store\u0026quot;) -}}    Overwrite     Seting data which originates from condition datawill only overwrite it for the current file (All YAMLs within that file). For the next file the condition data is newly merged and therefor present again.  Overwrite the key layer1.overwrite\nstructure/layer_2/_overwrite.yaml ...  {{- $_ := set $.data.layer_1 \u0026quot;overwrite\u0026quot; \u0026quot;Not Overwritten by Layer2\u0026quot; -}}    The layer1.overwrite will not be overwritten in the result.\nUnset     Unseting data which originates from condition datawill only unset it for the current file (All YAMLs within that file). For the next file the condition data is newly merged and therefor present again.  Unsets the data key unwated and layer1.\nstructure/layer_2/_unset.yaml ...  {{- $_ := unset $.data \u0026quot;unwanted\u0026quot; -}} {{- $_ := unset $.data \u0026quot;layer1\u0026quot; -}}    The unwanted key will no longer be present, the layer1 will be present, since it\u0026rsquo;s from the layer1 condition.\n"},{"id":15,"href":"/usage/renderers/custom/","title":"Custom Renderers","parent":"Renderers","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-customization You can implement your own Renderer templates.\nConfiguration     General configuration for Renderers.\nAssignment     Content is not returned via YAML but directly performed on the $.content map. Since map operations in sprig are directly performed on the given structure, it\u0026rsquo;s unessecary to abstract it via a return value. The below example implements functions of our library chart. The advantage of the library functions is they accept key paths and don\u0026rsquo;t fail if a child element does not exist.\n{{- define \u0026#34;customization.renderer.content\u0026#34; -}} {{/* Add a new Field to the Content/Overwrite */}} {{- $_ := set $.content.metadata.labels (dict \u0026#34;new_label\u0026#34; \u0026#34;new_value\u0026#34;) -}} {{/* Library Set Function */}} {{- include \u0026#34;lib.utils.dicts.set\u0026#34; (dict \u0026#34;path\u0026#34; \u0026#34;metadata.labels\u0026#34; \u0026#34;data\u0026#34; $.content \u0026#34;value\u0026#34; (dict \u0026#34;new_label\u0026#34; \u0026#34;new_value\u0026#34;)) -}} {{/* Remove a field from the Content */}} {{- $_ := unset $.content.metadata \u0026#34;labels\u0026#34; -}} {{/* Library Unset Function */}} {{- include \u0026#34;lib.utils.dicts.unset\u0026#34; (dict \u0026#34;path\u0026#34; \u0026#34;metadata.labels\u0026#34; \u0026#34;data\u0026#34; $.content) -}} {{- end -}} After each renderer is executed, it\u0026rsquo;s checked, if the $.content key is still of kind map. If not, an error is thrown.\nIf you would like to redirect content from the root context, you need to create a new variable with the dereferenced context. Then you can redirect the data to the content map:\n{{- define \u0026#34;customization.renderer.context\u0026#34; -}} {{/* Dereference (No Pointer) */}} {{- $ctx := (fromYaml (toYaml $)) -}} {{/* Set Context (Here we need to dereference $ to dump it\u0026#39;s content. Otherwise it breaks the set function */}} {{- $_ := set $.content \u0026#34;ctx\u0026#34; $ctx -}} {{- end -}} Return     The following return values (YAML Print) are considered:\n  errors - \u0026lt;slice\u0026gt; A list of errors which occured during identifier evaluation. The error will make helmize fail with your error message.\n  debug - \u0026lt;slice\u0026gt; Debug output which can be seen in summary (If something isn\u0026rsquo;t doing what you thought it does).\n  The Values are not required to be returned, only if you would like to invoke error/debug messages\nTemplate     Here\u0026rsquo;s a minimalstic Renderer template to get started.\n{{- define \u0026#34;customization.renderer.template\u0026#34; -}} {{- $return := dict \u0026#34;errors\u0026#34; list \u0026#34;debug\u0026#34; list -}} {{/* Renderer Logic */}} ... {{/* Return Metadata (Errors/Debug) */}} {{- printf \u0026#34;%s\u0026#34; (toYaml $return) -}} {{- end -}} Context     That\u0026rsquo;s how the Root Context ($) looks like given to the renderer templates.\nContext ...  Key population:\n $.Wagon - Wagon Context (without .content) $.ctx - Global Context  # Content Of the current file content: # Content omitted # ... ## Wagon Context (1) Wagon: ... ## Global Context (2) ctx: ...    Example     Let\u0026rsquo;s create a new Renderer which injects a jmx sidecar to all pod parent manifests. We must create our Renderer in the templates directory of our chart.\nmkdir -p templates/renderer/ Then Let\u0026rsquo;s add this Template under templates/renderer/_sidecar.tpl\ntemplates/renderer/_sidecar.tpl ...  This Renderer checks the kind field within the content. If no kind field is present, an error is returned reflecting that. If a kind is set, it\u0026rsquo;s compared if it\u0026rsquo;s any of deployment, statefulset, daemonsetor pod. If any of those match, a predefined container template for the sidecar is appended to the container spec directly in the content. The path is different pod, since all the other kind\u0026rsquo;s implement as template a pod spec.\n{{- define \u0026#34;customization.renderers.sidecar\u0026#34; -}} {{- $return := dict \u0026#34;errors\u0026#34; list \u0026#34;debug\u0026#34; list -}} {{- $kind := (lower (default \u0026#34;\u0026#34; $.content.kind) | toString) -}} {{/* Verify if Kind persent */}} {{- if $kind -}} {{/* Same Spec Path */}} {{- if (has $kind (list \u0026#34;deployment\u0026#34; \u0026#34;statefulset\u0026#34; \u0026#34;daemonset\u0026#34;)) -}} {{- $_ := set $.content.spec.template.spec \u0026#34;containers\u0026#34; (append $.content.spec.template.spec.containers (fromYaml (include \u0026#34;customization.renderers.sidecar.template\u0026#34; $))) -}} {{/* Different Path for Pods */}} {{- else if (eq $kind \u0026#34;pod\u0026#34;) -}} {{- $_ := set $.content.spec \u0026#34;containers\u0026#34; (append $.content.spec.containers (fromYaml (include \u0026#34;customization.renderers.sidecar.template\u0026#34; $))) -}} {{- end -}} {{/* Set Error on empty Kind */}} {{- else -}} {{- $_ := set $return \u0026#34;errors\u0026#34; (append $return.errors \u0026#34;No Kind Defined\u0026#34;) -}} {{- end -}} {{/* Return Metadata (Errors/Debug) */}} {{- printf \u0026#34;%s\u0026#34; (toYaml $return) -}} {{- end -}} {{/* JMX Sidecar Container Template */}} {{- define \u0026#34;customization.renderers.sidecar.template\u0026#34; -}} name: \u0026#34;jmx\u0026#34; command: - java - -XX:+UnlockExperimentalVMOptions - -XX:+UseCGroupMemoryLimitForHeap - -XX:MaxRAMFraction=1 - -XshowSettings:vm - -jar - jmx_prometheus_httpserver.jar - \u0026#34;90001\u0026#34; - /opt/jmx-config/jmx-prometheus.yml ports: - name: \u0026#34;jmx\u0026#34; containerPort: 9001 {{- end -}}    Once the Renderer is created we need to reference in the configuration. In this case we want the Renderer to be executed for all files. So the config would look like this:\ninventory_directory: \u0026#34;structure/\u0026#34; file_config_key: \u0026#34;metadata.helmize\u0026#34; force: false conditions: - name: \u0026#34;resources\u0026#34; allow_root: true renderers: - \u0026#34;customization.renderers.sidecar\u0026#34; "},{"id":16,"href":"/guides/","title":"Guides","parent":"","content":"Helmize is a good match for Fluxcd. Especially when you start dealing with sub-dependencies. TBD\n"},{"id":17,"href":"/usage/identifiers/","title":"Identifiers","parent":"Usage","content":"Example https://github.com/buttahtoast/helmize/tree/main/examples/example-identifiers Identifiers are used to identify a file or a partial file. Based on identifiers files are merged together. File Configurationsmay influence the behavior. The subpath is not relevant in the identifier evaluation.\nPredefined     Regardless if you are using the default identifier template or your own. If the template returns an empty ID the file name where the resource originate from is used. Should there be multiple resources in that file which don\u0026rsquo;t evaluate dedicated identifiers, they are both assigned the same identifier (filename) and therefor merged.  Custom IDsare always used. If a manifest has the field kind and metadata.name it\u0026rsquo;s combined to {kind}-{metadata.name}.yaml which is added as identifier. If no custom IDsare set or those two data fields, the filename is used. The current template for identifiert evaluation can be found here:\n https://github.com/buttahtoast/helmize/blob/master/charts/helmize/templates/core/templates/_identifier.tpl  You can change the identifier templateReference     The identifier template which should be used is defined in the helmize configurationOutcomes Here are different outcomes for identifiers.\n Kind and Name In this example the kind and metadata.name are set.\nstructure/resources/configmap.yaml ...  apiVersion: v1 kind: ConfigMap metadata: name: my-configmap data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5    Results in the following IDs:\n configmap-my-configmap.yaml  Multi YAML ...  Outcome with multiple YAMLs in one file\nstructure/resources/configmap.yaml ...  --- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5 --- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap2 data: game.properties: | enemy: types: - imps - warriors player: maximumLives:10    Results in two dedicated elements. First one has ID:\n configmap-my-configmap.yaml  Second one has ID:\n configmap-my-configmap2.yaml     Without Kind and Name In this example the kind and metadata.name are not set. In this case the filename is used as id.\nstructure/resources/configmap.yaml ...  data: game.properties: |enemy: types: - alien - monsters player: maximumLives:5    Results in the following IDs:\n configmap.yaml  Multi YAML ...  Make sure to use same kinds when you don\u0026rsquo;t explicit define ids or if they don\u0026rsquo;t resolve via filename. If you have eg. a kind service and deployment in the same file they will be merged, which is not valid in kubernetes terms  Outcome with multiple YAMLs in one file\nstructure/resources/configmap.yaml ...  --- data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5 --- data: game.properties: | enemy: types: - imps - warriors player: maximumLives:10    Both elements have the same ID and merged:\n configmap.yaml     Custom ID In this example we define custom identifiers via the idfield.\nstructure/resources/configmap.yaml ...  helmize: id: - custom-id-1 - custom-id-2 data: game.properties: |enemy: types: - alien - monsters player: maximumLives:5    Results in the following IDs:\n custom-id-1 custom-id-2  Multi YAML ...  Outcome with multiple YAMLs in one file\nstructure/resources/configmap.yaml ...  --- helmize: id: - custom-id-1 - custom-id-2 data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5 --- helmize: id: - custom-id-3 - custom-id-4 data: game.properties: | enemy: types: - imps - warriors player: maximumLives:10    Results in two dedicated elements. First one has ID:\n custom-id-1 custom-id-2  Second one has ID:\n custom-id-3 custom-id-4     Custom ID + Kind and Name In this example we define custom identifiers via the id field. In addition the kind and metadata.name are set.\nstructure/resources/configmap.yaml ...  apiVersion: v1 kind: ConfigMap metadata: name: my-configmap id: - custom-id-1 - custom-id-2 data: game.properties: |enemy: types: - alien - monsters player: maximumLives:5    Results in the following IDs:\n configmap-my-configmap.yaml custom-id-1 custom-id-2  Multi YAML ...  Outcome with multiple YAMLs in one file\nstructure/resources/configmap.yaml ...  --- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap helmize: id: - custom-id-1 - custom-id-2 data: game.properties: | enemy: types: - alien - monsters player: maximumLives:5 --- apiVersion: v1 kind: ConfigMap metadata: name: my-configmap helmize: id: - custom-id-3 - custom-id-4 data: game.properties: | enemy: types: - imps - warriors player: maximumLives:10    Results in two dedicated elements. First one has ID:\n configmap-my-configmap.yaml custom-id-1 custom-id-2  Second one has ID:\n configmap-my-configmap.yaml custom-id-3 custom-id-4    "},{"id":18,"href":"/configuration/files/reference/","title":"Reference","parent":"Files","content":"Example configuration reference for files\n## File Configuration Key # http://helmize.dev/configuration/helmize/#file_config_key helmize: ## Identifiers # http://helmize.dev/configuration/files/#id id: - deploy - nginx ## No Match # http://helmize.dev/configuration/files/#no_match no_match: \u0026#34;skip\u0026#34; ## Max Match # http://helmize.dev/configuration/files/#max_match no_match: 5 ## Render # http://helmize.dev/configuration/files/#render render: false ## Subpath # http://helmize.dev/configuration/files/#subpath subpath: false ## Pattern # http://helmize.dev/configuration/files/#pattern pattern: true ## Fork # http://helmize.dev/configuration/files/#fork fork: true "},{"id":19,"href":"/configuration/helmize/reference/","title":"Reference","parent":"Helmize","content":"Example configuration reference with documentation links.\n## Inventory Directory # http://helmize.dev/configuration/helmize/#inventory_directory inventory_directory: \u0026#34;groups/\u0026#34; ## Force # http://helmize.dev/configuration/helmize/#force force: false ## File Extensions # http://helmize.dev/configuration/helmize/#file_extensions file_extensions: [ \u0026#34;yaml\u0026#34; ] ## File Excludes # http://helmize.dev/configuration/helmize/#file_excludes file_excludes: [ \u0026#34;kustomization\u0026#34; ] ## Identifier Template # http://helmize.dev/configuration/helmize/#identifier_template identifier_template: \u0026#34;custom.identifier.template\u0026#34; ## Render Template # http://helmize.dev/configuration/helmize/#render_template render_template: \u0026#34;custom.render.template\u0026#34; ## File Configuration Key # http://helmize.dev/configuration/helmize/#file_config_key file_config_key: \u0026#34;custom.config.key\u0026#34; ## helmize Renderers # http://helmize.dev/configuration/helmize/#post_renderers renderers: - \u0026#34;custom.post-renderer.1\u0026#34; - \u0026#34;custom.post-renderer.2\u0026#34; ## Conditions # http://helmize.dev/configuration/conditions/ conditions: # Condition \u0026#34;Base\u0026#34; ## Name # http://helmize.dev/configuration/conditions/#name - name: \u0026#34;base\u0026#34; ## Path # http://helmize.dev/configuration/conditions/#path path: \u0026#34;/base/\u0026#34; ## Allow Root # http://helmize.dev/configuration/conditions/#allow_root allow_root: false # Condition \u0026#34;Environment\u0026#34; ## Name # http://helmize.dev/configuration/conditions/#name  - name: \u0026#34;environment\u0026#34; ## Key # http://helmize.dev/configuration/conditions/#key key: \u0026#34;config.environment\u0026#34; ## Key Types # http://helmize.dev/configuration/conditions/#key_types key_types: [ \u0026#34;string\u0026#34; ] ## Required # http://helmize.dev/configuration/conditions/#required  required: false ## Default # http://helmize.dev/configuration/conditions/#default  default: \u0026#34;default\u0026#34; ## Filter # http://helmize.dev/configuration/conditions/#filter  filter: [ \u0026#34;dev\u0026#34; ] ## Reverse Filter # http://helmize.dev/configuration/conditions/#reverse_filter reverse_filter: false ## File Config # http://helmize.dev/configuration/conditions/#file_cfg file_cfg: pattern: true render: false ## Data # http://helmize.dev/configuration/conditions/#data data: static: condition: data ## Data Templates # http://helmize.dev/configuration/conditions/#tpls tpls: - \u0026#34;ingress.tpl\u0026#34; ## Renderers # http://helmize.dev/configuration/conditions/#renderers renderers: - \u0026#34;custom.condition.post-renderer.1\u0026#34; - \u0026#34;custom.condition.post-renderer.2\u0026#34; "},{"id":20,"href":"/usage/renderers/","title":"Renderers","parent":"Usage","content":"Renderers are executed after all the files are merged within the train. They allow to make changes on the resulting manifests or even validate the integrity of the content. Renderers are executed once all the the files are merged into wagons. In contrast to the Rendertemplate, renderers can be defined via conditions and globally. This allows to apply Renderers on files based on folder origin.\nPredefined     Helmize comes with simple Renderers, which can be referenced in the configuration. All the available Renderers can be found here:\n https://github.com/buttahtoast/helmize/blob/master/charts/helmize/templates/renderers/templates/  We are happy to accept any useful Renderers as contribution.\nReference     Renderers are referenced via configuration. You can either enable post renderers for all files via the helmize configurationor based on condition.\n"},{"id":21,"href":"/usage/render/","title":"Render","parent":"Usage","content":"The Render Template is executed at the end. When all the files are merged and the final output is generated. This template must output valid YAML so that Helm can use it for further operations.\nPredefined     The default Render template can be found here:\n https://github.com/buttahtoast/helmize/blob/master/charts/helmize/templates/render/templates/_default.tpl  You can change the Render TemplateReference     The render template which should be used is defined in the helmize configuration"},{"id":22,"href":"/usage/flags/","title":"Flags","parent":"Usage","content":"Flags are given as values\nHelmize File     --set helmize_file=\u0026lt;string\u0026gt;\nDefine a custom location for the helmize configuraitonfile. The path is realtiv to the chart root directory.\nhelm template . --set helmize_file=custom.yaml Force     --set helmize.force=\u0026lt;bool\u0026gt;\nThe Force flag is useful when you have errors while templating, but want to skip the errors:\nFound errors, please resolve those errors or use the force option (--set helmize.force=true): - error: No Kind Defined file: - super renderer: customization.renderers.sidecar This flag can also be set in the configurationShow Config     --set show_config=\u0026lt;bool\u0026gt;\nJust prints the resulting config, for validation if you use templating:\nhelm template . --set show_config=true --- # Source: example-customization/templates/deploy.yaml config: benchmark: false conditions: - allow_root: true name: resources - allow_root: true data: sample: data default: resources file_cfg: subpath: false name: additional renderers: - customization.renderers.additional debug: false file_config_key: metadata.helmize file_extensions: - .yaml - .yml - .tpl force: false global: {} helmize: {} helmize_file: \u0026#34;\u0026#34; identifier_template: customization.identifier.template inventory_directory: structure/ library: global: {} render_template: customization.render.template renderers: - customization.renderers.sidecar - customization.renderers.env show_config: false summary: false Summary     --set summary=\u0026lt;bool\u0026gt;\nFor such cases we have a summary which summarizes overything that happened during the helmize processing.\nYou can display the summary via values:\nhelm template . --set summary=true Template     You can include the summary template, which returns the summary as YAML:\n{{- $summary := fromYaml (include \u0026quot;inventory.render.func.summary\u0026quot; $) -}} This way you could further process the output of helmize or eg. generate a good overview in the NOTES.txt of your chart.\nDebug     --set debug=\u0026lt;bool\u0026gt;\nYou can see extended information in the summary by adding the debug flag (not the helm debug flag):\nhelm template . --set summary=true --set debug=true Template     If you want to include more information, when the debug flag is set to true, you can include the following statement. This template will return true if the debug flag was set:\ninclude \u0026#34;inventory.entrypoint.func.debug\u0026#34; $.ctx This should improve the experience and help you to debug your own templates.\nBenchmark     --set benchmark=\u0026lt;bool\u0026gt;\nTemplates benchmarks for different checkpoints. This can be combined with the summary flag. Mainly for development purposes.\n"},{"id":23,"href":"/","title":"","parent":"","content":"This project is in the early stages of development and still activiely maintained. You may encounter behavior that\u0026rsquo;s not intended when making use of the project. If you find any bugs or have any questions feel free to open an issue.\nCurrently I dedicate my free time to it. I welcome any contributions and any feedback.\n Why     We have created this solution since there was nothing that would let us deploy complex structures based on values that change. We started of using Kustomizebut as soon as you have factors like environment, location, customer etc. you end up with huge large folder structures. These structures make hard to integrate with any other system you may have in your CI/CD cycle and is hard to keep control of. Das Schiffdid a great job with an example bootstrap structure in combination with Kustomize. But Kustomize does not deliver enough flexibility for such complex deployments. Another approach would be using kraanwhich allows such control over layers.\nBut the easiest solution to this is creating a helm chart yourself and place some yaml files in it and then based on values given to the chart render the yaml or not. That\u0026rsquo;s where helmize comes into play.\nHow     Helmize is just a simple chart library which simplifies creating complex infrastructure deployments within helm charts. Through the use of Helm you don\u0026rsquo;t need any additional operator or anything. It greatly integrates in any tool chain since you can customize it to your needs. It is complementary since it\u0026rsquo;s just advanced rendering in a helm chart, that means you can deploy any other crds or whatever you need (eg. kraan layers).\nRead MoreWho     This project is thought for people that bootstrap complex infrastructure setup on kubernetes and want the entire setup to be value driven. If you are looking for a simple solution for eg. a deployment for a single application this project might be too much overhead. If you have already experience with Helm it might be worth taking a look.\n"},{"id":24,"href":"/categories/","title":"Categories","parent":"","content":""},{"id":25,"href":"/tags/","title":"Tags","parent":"","content":""}]